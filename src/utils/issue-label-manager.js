/**
 * Issue Label Manager for AI Code Review System
 * Automatically applies appropriate labels to GitHub issues
 */
class IssueLabelManager {
  constructor(config = {}) {
    this.config = {
      // Default label sets
      labelSets: {
        // Severity-based labels
        severity: {
          critical: { name: 'severity:critical', color: 'd73a4a', description: 'Critical issue requiring immediate attention' },
          high: { name: 'severity:high', color: 'fbca04', description: 'High priority issue' },
          medium: { name: 'severity:medium', color: 'fef2c0', description: 'Medium priority issue' },
          low: { name: 'severity:low', color: 'd4c5f9', description: 'Low priority issue' },
          info: { name: 'severity:info', color: 'bfdadc', description: 'Informational issue' }
        },
        
        // Issue type labels
        type: {
          security: { name: 'type:security', color: 'd73a4a', description: 'Security-related issue' },
          performance: { name: 'type:performance', color: 'fbca04', description: 'Performance-related issue' },
          bug: { name: 'type:bug', color: 'd73a4a', description: 'Bug or defect' },
          quality: { name: 'type:quality', color: '0075ca', description: 'Code quality issue' },
          style: { name: 'type:style', color: 'bfdadc', description: 'Code style or formatting issue' },
          architecture: { name: 'type:architecture', color: '0075ca', description: 'Architectural issue' },
          documentation: { name: 'type:documentation', color: '0075ca', description: 'Documentation issue' },
          testing: { name: 'type:testing', color: '0e8a16', description: 'Testing-related issue' }
        },
        
        // Priority labels
        priority: {
          immediate: { name: 'priority:immediate', color: 'd73a4a', description: 'Immediate action required' },
          high: { name: 'priority:high', color: 'fbca04', description: 'High priority' },
          normal: { name: 'priority:normal', color: '0075ca', description: 'Normal priority' },
          low: { name: 'priority:low', color: 'bfdadc', description: 'Low priority' },
          lowest: { name: 'priority:lowest', color: 'bfdadc', description: 'Lowest priority' }
        },
        
        // Status labels
        status: {
          new: { name: 'status:new', color: '0075ca', description: 'New issue' },
          assigned: { name: 'status:assigned', color: 'fbca04', description: 'Issue assigned to team member' },
          in_progress: { name: 'status:in-progress', color: 'fbca04', description: 'Work in progress' },
          review: { name: 'status:review', color: 'fbca04', description: 'Under review' },
          blocked: { name: 'status:blocked', color: 'd73a4a', description: 'Blocked by dependency' },
          resolved: { name: 'status:resolved', color: '0e8a16', description: 'Issue resolved' },
          closed: { name: 'status:closed', color: '6f42c1', description: 'Issue closed' }
        },
        
        // Component labels
        component: {
          frontend: { name: 'component:frontend', color: '0075ca', description: 'Frontend component' },
          backend: { name: 'component:backend', color: '0075ca', description: 'Backend component' },
          database: { name: 'component:database', color: '0075ca', description: 'Database component' },
          api: { name: 'component:api', color: '0075ca', description: 'API component' },
          infrastructure: { name: 'component:infrastructure', color: '0075ca', description: 'Infrastructure component' },
          security: { name: 'component:security', color: '0075ca', description: 'Security component' },
          testing: { name: 'component:testing', color: '0075ca', description: 'Testing component' }
        },
        
        // Technology labels
        technology: {
          javascript: { name: 'tech:javascript', color: 'f1e05a', description: 'JavaScript/Node.js' },
          typescript: { name: 'tech:typescript', color: '2b7489', description: 'TypeScript' },
          python: { name: 'tech:python', color: '3572A5', description: 'Python' },
          java: { name: 'tech:java', color: 'b07219', description: 'Java' },
          csharp: { name: 'tech:csharp', color: '178600', description: 'C#' },
          go: { name: 'tech:go', color: '00ADD8', description: 'Go' },
          rust: { name: 'tech:rust', color: 'dea584', description: 'Rust' },
          php: { name: 'tech:php', color: '4F5D95', description: 'PHP' },
          ruby: { name: 'tech:ruby', color: '701516', description: 'Ruby' }
        },
        
        // Special labels
        special: {
          ai_review: { name: 'ai-review', color: '6f42c1', description: 'Generated by AI Code Review' },
          auto_assigned: { name: 'auto-assigned', color: 'bfdadc', description: 'Automatically assigned' },
          needs_triage: { name: 'needs-triage', color: 'fbca04', description: 'Needs initial triage' },
          good_first_issue: { name: 'good first issue', color: '0e8a16', description: 'Good for new contributors' },
          help_wanted: { name: 'help wanted', color: '0075ca', description: 'Help needed' },
          enhancement: { name: 'enhancement', color: 'a2eeef', description: 'New feature or request' },
          wontfix: { name: 'wontfix', color: 'ffffff', description: 'Will not be fixed' }
        }
      },
      
      // Label application rules
      labelRules: {
        // Automatic labels based on issue type
        autoLabels: {
          security: ['type:security', 'ai-review', 'needs-triage'],
          performance: ['type:performance', 'ai-review'],
          bug: ['type:bug', 'ai-review', 'needs-triage'],
          quality: ['type:quality', 'ai-review'],
          style: ['type:style', 'ai-review'],
          architecture: ['type:architecture', 'ai-review'],
          documentation: ['type:documentation', 'ai-review'],
          testing: ['type:testing', 'ai-review']
        },
        
        // Labels based on severity
        severityLabels: {
          critical: ['severity:critical', 'priority:immediate'],
          high: ['severity:high', 'priority:high'],
          medium: ['severity:medium', 'priority:normal'],
          low: ['severity:low', 'priority:low'],
          info: ['severity:info', 'priority:lowest']
        },
        
        // Labels based on file path
        pathLabels: {
          'frontend/': ['component:frontend'],
          'backend/': ['component:backend'],
          'api/': ['component:api'],
          'database/': ['component:database'],
          'infrastructure/': ['component:infrastructure'],
          'security/': ['component:security'],
          'tests/': ['component:testing'],
          '.js': ['tech:javascript'],
          '.ts': ['tech:typescript'],
          '.py': ['tech:python'],
          '.java': ['tech:java'],
          '.cs': ['tech:csharp'],
          '.go': ['tech:go'],
          '.rs': ['tech:rust'],
          '.php': ['tech:php'],
          '.rb': ['tech:ruby']
        },
        
        // Labels based on issue content
        contentLabels: {
          'sql injection': ['type:security', 'needs-triage'],
          'xss': ['type:security', 'needs-triage'],
          'buffer overflow': ['type:security', 'needs-triage'],
          'memory leak': ['type:performance', 'needs-triage'],
          'race condition': ['type:bug', 'needs-triage'],
          'deadlock': ['type:bug', 'needs-triage'],
          'infinite loop': ['type:bug', 'needs-triage'],
          'null pointer': ['type:bug', 'needs-triage'],
          'hardcoded': ['type:security', 'needs-triage'],
          'weak encryption': ['type:security', 'needs-triage'],
          'insecure random': ['type:security', 'needs-triage'],
          'path traversal': ['type:security', 'needs-triage'],
          'command injection': ['type:security', 'needs-triage'],
          'privilege escalation': ['type:security', 'needs-triage']
        }
      },
      
      // Label management settings
      management: {
        autoCreateLabels: true,
        autoUpdateLabels: true,
        preserveExistingLabels: true,
        maxLabelsPerIssue: 10,
        labelConflictResolution: 'merge' // merge, replace, skip
      },
      
      ...config
    };
    
    this.labelCache = new Map();
    this.labelHistory = new Map();
  }

  /**
   * Generate labels for an issue
   * @param {Object} issue - Issue data
   * @param {Object} context - Review context
   * @returns {Object} Label generation result
   */
  generateLabels(issue, context = {}) {
    try {
      console.log(`🏷️ Generating labels for issue: ${issue.type} - ${issue.severity}`);
      
      const labels = new Set();
      const labelSources = [];
      
      // Step 1: Apply automatic type-based labels
      const typeLabels = this.getTypeLabels(issue.type);
      typeLabels.forEach(label => {
        labels.add(label);
        labelSources.push({ label, source: 'type', reason: `Issue type: ${issue.type}` });
      });
      
      // Step 2: Apply severity-based labels
      const severityLabels = this.getSeverityLabels(issue.severity);
      severityLabels.forEach(label => {
        labels.add(label);
        labelSources.push({ label, source: 'severity', reason: `Severity: ${issue.severity}` });
      });
      
      // Step 3: Apply path-based labels
      if (issue.file) {
        const pathLabels = this.getPathLabels(issue.file);
        pathLabels.forEach(label => {
          labels.add(label);
          labelSources.push({ label, source: 'path', reason: `File path: ${issue.file}` });
        });
      }
      
      // Step 4: Apply content-based labels
      if (issue.description) {
        const contentLabels = this.getContentLabels(issue.description);
        contentLabels.forEach(label => {
          labels.add(label);
          labelSources.push({ label, source: 'content', reason: 'Content analysis' });
        });
      }
      
      // Step 5: Apply context-based labels
      const contextLabels = this.getContextLabels(context);
      contextLabels.forEach(label => {
        labels.add(label);
        labelSources.push({ label, source: 'context', reason: 'Context analysis' });
      });
      
      // Step 6: Apply assignment-based labels
      if (issue.assignedTo) {
        const assignmentLabels = this.getAssignmentLabels(issue);
        assignmentLabels.forEach(label => {
          labels.add(label);
          labelSources.push({ label, source: 'assignment', reason: 'Assignment analysis' });
        });
      }
      
      // Step 7: Apply special labels
      const specialLabels = this.getSpecialLabels(issue, context);
      specialLabels.forEach(label => {
        labels.add(label);
        labelSources.push({ label, source: 'special', reason: 'Special conditions' });
      });
      
      // Convert to array and limit labels
      const labelArray = Array.from(labels).slice(0, this.config.management.maxLabelsPerIssue);
      
      const result = {
        labels: labelArray,
        sources: labelSources.filter(source => labelArray.includes(source.label)),
        metadata: {
          totalGenerated: labels.size,
          totalApplied: labelArray.length,
          truncated: labels.size > this.config.management.maxLabelsPerIssue,
          generationTime: new Date()
        }
      };
      
      console.log(`✅ Generated ${labelArray.length} labels for issue`);
      
      return result;
      
    } catch (error) {
      console.error('❌ Label generation failed:', error.message);
      return this.createFallbackLabels(issue);
    }
  }

  /**
   * Get type-based labels
   * @param {string} issueType - Issue type
   * @returns {Array} Type labels
   */
  getTypeLabels(issueType) {
    const rule = this.config.labelRules.autoLabels[issueType];
    return rule ? rule : ['ai-review'];
  }

  /**
   * Get severity-based labels
   * @param {string} severity - Issue severity
   * @returns {Array} Severity labels
   */
  getSeverityLabels(severity) {
    const rule = this.config.labelRules.severityLabels[severity];
    return rule ? rule : ['ai-review'];
  }

  /**
   * Get path-based labels
   * @param {string} filePath - File path
   * @returns {Array} Path labels
   */
  getPathLabels(filePath) {
    const labels = [];
    const path = filePath.toLowerCase();
    
    // Check component labels
    Object.entries(this.config.labelRules.pathLabels).forEach(([pattern, labelList]) => {
      if (path.includes(pattern.replace('*', ''))) {
        labels.push(...labelList);
      }
    });
    
    // Check file extension
    const extension = path.split('.').pop();
    if (extension && this.config.labelRules.pathLabels[`.${extension}`]) {
      labels.push(...this.config.labelRules.pathLabels[`.${extension}`]);
    }
    
    return labels;
  }

  /**
   * Get content-based labels
   * @param {string} description - Issue description
   * @returns {Array} Content labels
   */
  getContentLabels(description) {
    const labels = [];
    const text = description.toLowerCase();
    
    Object.entries(this.config.labelRules.contentLabels).forEach(([pattern, labelList]) => {
      if (text.includes(pattern.toLowerCase())) {
        labels.push(...labelList);
      }
    });
    
    return labels;
  }

  /**
   * Get context-based labels
   * @param {Object} context - Review context
   * @returns {Array} Context labels
   */
  getContextLabels(context) {
    const labels = [];
    
    // Check if it's a critical file
    if (context.fileImportance === 'critical') {
      labels.push('needs-triage');
    }
    
    // Check if it's a public API
    if (context.isPublicAPI) {
      labels.push('component:api');
    }
    
    // Check if it's configuration-related
    if (context.isConfiguration) {
      labels.push('component:infrastructure');
    }
    
    // Check if it's a new feature
    if (context.changeType === 'addition') {
      labels.push('enhancement');
    }
    
    return labels;
  }

  /**
   * Get assignment-based labels
   * @param {Object} issue - Issue data
   * @returns {Array} Assignment labels
   */
  getAssignmentLabels(issue) {
    const labels = [];
    
    if (issue.assignedTo) {
      labels.push('status:assigned');
      labels.push('auto-assigned');
    }
    
    // Check if it's a good first issue
    if (issue.severity === 'low' && issue.type === 'style') {
      labels.push('good first issue');
    }
    
    // Check if help is needed
    if (issue.severity === 'critical' || issue.severity === 'high') {
      labels.push('help wanted');
    }
    
    return labels;
  }

  /**
   * Get special labels
   * @param {Object} issue - Issue data
   * @param {Object} context - Review context
   * @returns {Array} Special labels
   */
  getSpecialLabels(issue, context) {
    const labels = [];
    
    // Check for repeated issues
    if (this.isRepeatedIssue(issue, context)) {
      labels.push('needs-triage');
    }
    
    // Check for security implications
    if (this.hasSecurityImplications(issue)) {
      labels.push('needs-triage');
    }
    
    // Check for performance impact
    if (this.hasPerformanceImpact(issue)) {
      labels.push('needs-triage');
    }
    
    return labels;
  }

  /**
   * Check if issue is repeated
   * @param {Object} issue - Issue data
   * @param {Object} context - Review context
   * @returns {boolean} True if repeated
   */
  isRepeatedIssue(issue, context) {
    // This would integrate with the issue history system
    // For now, return false
    return false;
  }

  /**
   * Check if issue has security implications
   * @param {Object} issue - Issue data
   * @returns {boolean} True if security-related
   */
  hasSecurityImplications(issue) {
    if (issue.type === 'security') return true;
    
    const securityKeywords = ['password', 'token', 'secret', 'key', 'auth', 'permission', 'vulnerability'];
    const description = issue.description?.toLowerCase() || '';
    
    return securityKeywords.some(keyword => description.includes(keyword));
  }

  /**
   * Check if issue has performance impact
   * @param {Object} issue - Issue data
   * @returns {boolean} True if performance-related
   */
  hasPerformanceImpact(issue) {
    if (issue.type === 'performance') return true;
    
    const performanceKeywords = ['slow', 'bottleneck', 'memory', 'cpu', 'timeout', 'latency'];
    const description = issue.description?.toLowerCase() || '';
    
    return performanceKeywords.some(keyword => description.includes(keyword));
  }

  /**
   * Create fallback labels
   * @param {Object} issue - Issue data
   * @returns {Object} Fallback label result
   */
  createFallbackLabels(issue) {
    const fallbackLabels = ['ai-review', 'needs-triage'];
    
    if (issue.type) {
      fallbackLabels.push(`type:${issue.type}`);
    }
    
    if (issue.severity) {
      fallbackLabels.push(`severity:${issue.severity}`);
    }
    
    return {
      labels: fallbackLabels,
      sources: fallbackLabels.map(label => ({
        label,
        source: 'fallback',
        reason: 'Fallback due to generation error'
      })),
      metadata: {
        totalGenerated: fallbackLabels.length,
        totalApplied: fallbackLabels.length,
        truncated: false,
        generationTime: new Date(),
        fallback: true
      }
    };
  }

  /**
   * Merge labels with existing labels
   * @param {Array} newLabels - New labels to add
   * @param {Array} existingLabels - Existing labels
   * @returns {Array} Merged labels
   */
  mergeLabels(newLabels, existingLabels = []) {
    if (!this.config.management.preserveExistingLabels) {
      return newLabels;
    }
    
    const merged = new Set([...existingLabels, ...newLabels]);
    return Array.from(merged).slice(0, this.config.management.maxLabelsPerIssue);
  }

  /**
   * Validate label format
   * @param {string} label - Label to validate
   * @returns {boolean} True if valid
   */
  validateLabel(label) {
    // GitHub label requirements
    const maxLength = 50;
    const validChars = /^[a-zA-Z0-9\-_]+$/;
    
    return label.length <= maxLength && validChars.test(label);
  }

  /**
   * Clean label text
   * @param {string} label - Label to clean
   * @returns {string} Cleaned label
   */
  cleanLabel(label) {
    return label
      .toLowerCase()
      .replace(/[^a-z0-9\-_]/g, '-')
      .replace(/-+/g, '-')
      .replace(/^-|-$/g, '')
      .substring(0, 50);
  }

  /**
   * Get label metadata
   * @param {string} labelName - Label name
   * @returns {Object|null} Label metadata
   */
  getLabelMetadata(labelName) {
    // Search through all label sets
    for (const [setName, labels] of Object.entries(this.config.labelSets)) {
      for (const [key, metadata] of Object.entries(labels)) {
        if (metadata.name === labelName) {
          return { ...metadata, set: setName, key };
        }
      }
    }
    
    return null;
  }

  /**
   * Create label definition for GitHub
   * @param {string} labelName - Label name
   * @returns {Object} GitHub label definition
   */
  createLabelDefinition(labelName) {
    const metadata = this.getLabelMetadata(labelName);
    
    if (metadata) {
      return {
        name: metadata.name,
        color: metadata.color,
        description: metadata.description
      };
    }
    
    // Default label definition
    return {
      name: labelName,
      color: '0366d6', // GitHub blue
      description: `Auto-generated label: ${labelName}`
    };
  }

  /**
   * Get all available labels
   * @returns {Object} All available labels organized by set
   */
  getAllLabels() {
    return this.config.labelSets;
  }

  /**
   * Get label statistics
   * @returns {Object} Label usage statistics
   */
  getLabelStats() {
    const stats = {
      totalLabels: 0,
      bySet: {},
      bySource: {},
      mostUsed: [],
      recentlyUsed: []
    };
    
    // Count labels by set
    Object.entries(this.config.labelSets).forEach(([setName, labels]) => {
      stats.bySet[setName] = Object.keys(labels).length;
      stats.totalLabels += Object.keys(labels).length;
    });
    
    // Count labels by source
    this.labelHistory.forEach((usage, label) => {
      const source = usage.source || 'unknown';
      stats.bySource[source] = (stats.bySource[source] || 0) + 1;
    });
    
    // Get most used labels
    const labelUsage = Array.from(this.labelHistory.entries()).map(([label, usage]) => ({
      label,
      count: usage.count || 0,
      lastUsed: usage.lastUsed
    }));
    
    stats.mostUsed = labelUsage
      .sort((a, b) => b.count - a.count)
      .slice(0, 10);
    
    stats.recentlyUsed = labelUsage
      .filter(usage => usage.lastUsed)
      .sort((a, b) => new Date(b.lastUsed) - new Date(a.lastUsed))
      .slice(0, 10);
    
    return stats;
  }

  /**
   * Update label usage history
   * @param {string} label - Label name
   * @param {string} source - Label source
   */
  updateLabelHistory(label, source) {
    if (!this.labelHistory.has(label)) {
      this.labelHistory.set(label, { count: 0, lastUsed: null, source });
    }
    
    const usage = this.labelHistory.get(label);
    usage.count++;
    usage.lastUsed = new Date();
  }

  /**
   * Clear label history
   */
  clearHistory() {
    this.labelHistory.clear();
  }
}

module.exports = IssueLabelManager;

